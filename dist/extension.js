(()=>{"use strict";var __webpack_modules__={112:function(__unused_webpack_module,exports,__webpack_require__){eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.deactivate = exports.activate = void 0;\r\nconst vscode = __webpack_require__(549);\r\nconst cp = __webpack_require__(129);\r\nlet lastCodeBlock = \"\"; //code for execution\r\nlet startCode = 0; //start line of code\r\nlet lastResult = ''; //output from code execution\r\nlet swap = ''; //3 char string to indicate pos for in-line result\r\nlet swapExp = ''; //expression in script language to produce in-line result\r\nlet tempd = ''; //folder for temp files (provided by vscode)\r\nlet temp = ''; //file name of temp file for current script\r\nlet cd = ''; //code default start line for current script\r\nlet ex = ''; //execution id for current script\r\nlet exec = ''; //javascript to start current script execution\r\nlet msg = ''; //message for hover, derived from ``` line\r\nlet arr; //array of strings for current 'built-in' script\r\nlet shown = false; //progress message 1 showinf\r\nlet currentFolder = ''; //folder containing current edit file\r\nlet currentFile = ''; //name of current edit file\r\nlet executing = false; //code is executing\r\nlet nexec = 0; //number of curren\ttly executing code (auto incremented)\r\nlet oneLiner = false; //current script is a 'one-liner'\r\nlet ch; //child process executing current script\r\nlet a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z; //variables for use in eval codeblocks\r\nlet replaceSel = new vscode.Selection(0, 0, 0, 0); //section in current editor which will be replaced\r\nlet config = vscode.workspace.getConfiguration('hover-exec');\r\nfunction activate(context) {\r\n    context.subscriptions.push(vscode.workspace.onDidChangeConfiguration(e => {\r\n        config = vscode.workspace.getConfiguration('hover-exec'); //update config\r\n    }));\r\n    context.subscriptions.push(vscode.window.registerUriHandler(new MyUriHandler()));\r\n    vscode.languages.registerHoverProvider('markdown', new (class {\r\n        provideHover(doc, pos, token) {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                const line = doc.lineAt(pos); //user is currently hovering over this line    \r\n                if (!line.text.startsWith('```') || line.text === '```') {\r\n                    return null;\r\n                } //if not a code block line with id, ignore\r\n                if (executing) { //if already executing code block, show cancel option\r\n                    return new vscode.Hover(new vscode.MarkdownString('*hover-exec:* executing...\\n\\n[cancel execution](vscode://rmzetti.hover-exec?abort)'));\r\n                }\r\n                currentFile = doc.uri.path.substring(1); //currentfile, can be used in exec commands as %e\r\n                currentFolder = doc.uri.path.substring(1, doc.uri.path.lastIndexOf('/') + 1); // folder, %c\r\n                if (currentFolder.slice(1, 2) !== ':') {\r\n                    currentFolder = fixFolder(currentFolder);\r\n                } //win vs linux\r\n                vscode.workspace.fs.createDirectory(context.globalStorageUri); //create temp folder if necessary\r\n                cd = ''; //reset code default start line\r\n                startCode = pos.line; //save start of code line number\r\n                oneLiner = line.text.slice(3).includes('```');\r\n                temp = 'temp.txt'; //temporary file name, can be used as %n\r\n                tempd = context.globalStorageUri.fsPath + '/'; //temp folder path, %p\r\n                swap = '';\r\n                swapExp = ''; //default is empty string\r\n                ex = getcmd(line.text); //command id, performs {...} changes\r\n                msg = getmsg(line.text); //message for hover\r\n                let ex1 = ex.replace(/\\s.*/, ''); //check for predefined commands (no spaces)\r\n                arr = config.get(ex1); //get command strings if available\r\n                if (arr) { //predefined script engine strings\r\n                    ex = ex1;\r\n                    getScriptSettings(currentFolder); //get predefined command strings (& expand %f etc)\r\n                    lastCodeBlock = getCodeBlockAt(doc, pos); //save codeblock\r\n                    let url = 'vscode://rmzetti.hover-exec?' + ex; //url for hover\r\n                    if (swap !== '') {\r\n                        msg += '  ... *use ' + swap + ' for inline results*';\r\n                    } //get msg etc for hover info\r\n                    msg = '*[ \\[last script\\] ](' + fixFolder(tempd) + temp + ')* ' + //create last script/result urls\r\n                        '*[ \\[last result\\] ](' + fixFolder(tempd) + temp + '.out.txt)*\\n\\n' + '[ ' + ex + msg + '](' + url + ')';\r\n                    const contents = new vscode.MarkdownString('*hover-exec:* ' + msg);\r\n                    contents.isTrusted = true; //create complete hover message, declare as trusted\r\n                    return new vscode.Hover(contents); //and return it\r\n                }\r\n                else if (ex === 'output') { //create & return message & urls for output hover\r\n                    ex = 'delete';\r\n                    return new vscode.Hover(new vscode.MarkdownString('*hover-exec:*\\n\\n[output to text](vscode://rmzetti.hover-exec?remove)\\n\\n' +\r\n                        '[delete output](vscode://rmzetti.hover-exec?delete)'));\r\n                }\r\n                else {\r\n                    if (oneLiner) { //create & return hover-message and urls for one-liners\r\n                        exec = line.text.slice(3).replace(/{.*}/, ''); //exec is start command, next line substitutes %f etc\r\n                        exec = replaceStrVars(exec.slice(0, exec.indexOf('```')).replace(/%20/mg, ' '));\r\n                        ex = 'exe'; //ex is command id\r\n                        let url = 'vscode://rmzetti.hover-exec?' + ex; //create hover message, declare as trusted, and return it\r\n                        const contents = new vscode.MarkdownString('*hover-exec:* ' + msg + '\\n\\n[' + exec + '](' + url + ')');\r\n                        contents.isTrusted = true;\r\n                        return new vscode.Hover(contents);\r\n                    }\r\n                    else { //create and return hover message & urls for non-standard commands\r\n                        exec = (ex + ' \"' + tempd + temp + '\"').replace(/%20/mg, ' ');\r\n                        lastCodeBlock = getCodeBlockAt(doc, pos);\r\n                        let url = 'vscode://rmzetti.hover-exec?' + ex.replace(/\\s/mg, '%20');\r\n                        msg = '[' + ex + msg + '](' + url + ')';\r\n                        msg = '*[ \\[last script\\] ](' + fixFolder(tempd) + temp + ')*\\n\\n' + msg;\r\n                        const contents = new vscode.MarkdownString('*hover-exec:* ' + msg);\r\n                        contents.isTrusted = true;\r\n                        return new vscode.Hover(contents);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    })());\r\n}\r\nexports.activate = activate;\r\nclass MyUriHandler {\r\n    handleUri(uri) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            //handle clicked hover exec commands\r\n            nexec += 1; //script exec number for check to ensure output is from latest script \r\n            if (uri.query === 'abort') { //cancel has been clicked, kill executing task\r\n                executing = false;\r\n                ch.kill();\r\n                return;\r\n            }\r\n            if (uri.query === 'delete') {\r\n                deleteOutput(false);\r\n                return;\r\n            } //delete output codeblock\r\n            if (uri.query === 'remove') {\r\n                deleteOutput(true);\r\n                return;\r\n            } //change output codeblock to text\r\n            if (lastCodeBlock.includes('=>>') || lastCodeBlock.includes('=<<')) {\r\n                //allows for earlier version in-line output in form =<< ... >>\r\n                lastCodeBlock = lastCodeBlock.replace(/=<</g, '=>>');\r\n                swap = '=>>'; //use =>> as swap indicator (overrides presets)\r\n            }\r\n            let sCode = lastCodeBlock;\r\n            if (swap !== '') {\r\n                let re = new RegExp(swap + '.*', 'mg');\r\n                lastCodeBlock = lastCodeBlock.replace(re, swap); //remove previous in-line results\r\n                re = new RegExp('^(.*)' + swap, 'mg'); //insert swap code into code block script as needed\r\n                sCode = lastCodeBlock.replace(re, swapExp); //update sCode\r\n            }\r\n            vscode.window.withProgress({\r\n                location: vscode.ProgressLocation.Window,\r\n                title: 'Hover-exec'\r\n            }, (progress) => __awaiter(this, void 0, void 0, function* () {\r\n                executing = true;\r\n                let iexec = nexec; //save exec number for this script\r\n                progress.report({ message: 'executing' });\r\n                writeFile(tempd + temp, cd + sCode); //saves code in temp file for execution\r\n                eval('process.chdir(\"' + currentFolder + '\")'); //change to current directory\r\n                if (ex !== '') {\r\n                    if (ex === 'eval') { //eval uses vscode internal js eval\r\n                        //progress1('started');\r\n                        //lastResult=eval(cd+sCode)+'\\n';\t\t//need to do separate lines rather than this\r\n                        //because eval returns output from only the last evaluated statement\r\n                        let s1 = sCode.split(/\\r?\\n/), s2 = '';\r\n                        lastResult = '';\r\n                        s1.forEach((line) => {\r\n                            s2 = eval(line); //line by line execution of code\r\n                            if (s2 && !line.endsWith(';')) {\r\n                                lastResult += s2 + '\\n';\r\n                            } //if(s2) avoids 'undefined'\r\n                        });\r\n                    }\r\n                    else if (ex === 'exe') { //exe is one-liner\r\n                        yield execShell(exec);\r\n                        executing = false;\r\n                        return; //one-liners do not produce output\r\n                    }\r\n                    else {\r\n                        lastResult = yield execShell(exec);\r\n                    }\r\n                    if (ex === 'buddvs') {\r\n                        lastResult = lastResult.replace(/�/g, 'î');\r\n                    } //test scripter\r\n                }\r\n                else {\r\n                    lastResult = uri.toString();\r\n                }\r\n                //output to output file and editor\r\n                if (iexec === nexec) { //only output if this is the latest result\r\n                    writeFile(tempd + temp + '.out.txt', lastResult);\r\n                    if (lastResult !== '') {\r\n                        paste(lastResult); //paste into editor\r\n                        removeSelection(); //deselect\r\n                    }\r\n                    executing = false; //execution finished\r\n                }\r\n                ;\r\n            }));\r\n        });\r\n    }\r\n}\r\nfunction paste(text) {\r\n    const { activeTextEditor } = vscode.window;\r\n    if (activeTextEditor && startCode > 0) {\r\n        //remove any 'object promise' message\r\n        if (ex === 'eval') {\r\n            text = text.replace(/\\[object Promise\\]/g, '');\r\n        }\r\n        if (swap !== \"\") { //if doing in-line output\r\n            let re = new RegExp(swap + '.*', 'mg'); //regex to look for swap strings\r\n            lastCodeBlock = lastCodeBlock.replace(re, swap); //remove all after swap strings\r\n            let re1 = new RegExp(swap + '$', 'm');\r\n            if (re1.test(lastCodeBlock)) { //if there are any swap strings\r\n                //copy intermediate results into the codeblock\r\n                re = new RegExp('^.*{{.*}}$', 'm'); //regex to find the next\r\n                while (re1.test(lastCodeBlock)) { //while there is a swap string to replace\r\n                    let i = text.indexOf('{{') + 2, j = text.indexOf('}}\\r'); //find the next swappable {{output}}\r\n                    if (j < 0) {\r\n                        j = text.indexOf('}}\\n');\r\n                    } //to allow \\n, \\r & \\r\\n\r\n                    if (i > 0 && j >= i) {\r\n                        let s = text.substring(i, j).replace(/\\r?\\n/, ';'); //remove newlines in in-line results\r\n                        if (s === '') {\r\n                            s = ';';\r\n                        }\r\n                        lastCodeBlock = lastCodeBlock.replace(swap + '\\n', swap + s + '\\n'); //do the swap\r\n                        text = text.replace(re, ''); //remove the swapped output to clear for the next\r\n                    }\r\n                    else {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        text = text.replace(/^\\s*$/gm, '').trim(); //remove blank lines\r\n        //if there is any output left, it will go into an ```output codeblock\r\n        activeTextEditor.edit((selText) => {\r\n            selectCodeblock(); //select codeblock to replace\r\n            if (text === '') { //no unused output\r\n                selText.replace(replaceSel, lastCodeBlock + \"```\\n\");\r\n            }\r\n            else if (oneLiner) { //produce an output block for a one-liner\r\n                selText.replace(replaceSel, \"```output\\n\" + text + \"\\n```\\n\");\r\n            }\r\n            else { //replace the original text/output (text now includes inline results)\r\n                selText.replace(replaceSel, lastCodeBlock + \"```\\n```output\\n\" + text + \"\\n```\\n\");\r\n            }\r\n        });\r\n    }\r\n}\r\nfunction fixFolder(f) {\r\n    if (f.startsWith('\\\\')) {\r\n        f = f.slice(1);\r\n    }\r\n    if (!f.startsWith('/')) {\r\n        f = '/' + f;\r\n    }\r\n    return f;\r\n}\r\nfunction getcmd(s) {\r\n    if (s.includes('ext=')) { //allow specification of temp file ext, eg {ext=py}\r\n        temp = 'temp.' + s.replace(/.*ext=(.*?)[\\s\\,\\}].*/, '$1').replace(/[\"']/g, '');\r\n    }\r\n    if (s.includes('cmd=')) { //allow spec of command, eg. {cmd=python3}\r\n        return s.replace(/.*cmd=(.*?)[\\s\\,\\}].*/, '$1').replace(/[\"']/g, '');\r\n    }\r\n    s = s.slice(3); //remove initial backtics\r\n    if (s.startsWith('\"')) { //return quoted bit as command\r\n        return s.slice(1).replace(/\".*/, '');\r\n    }\r\n    s = s.replace(/```.*/, ''); //remove everything after last backtics (if on the start line)\r\n    let ipos = posComment(s); //find comment in command line (std comment formats)\r\n    if (ipos > 0) {\r\n        s = s.slice(0, ipos);\r\n    }\r\n    ex = s.replace(/{.*}/, '').trim(); //return trimmed line without comments as command\r\n    return ex;\r\n}\r\nfunction getmsg(s) {\r\n    //get message for hover from ```command line\r\n    let msg = '';\r\n    s = s.slice(3).replace(/.*```/, ''); //removebacktics\r\n    let ipos = posComment(s); //find comment in command line\r\n    if (ipos > 0) {\r\n        msg = ' ' + s.substr(ipos);\r\n    } //use comments in hover message\r\n    return msg;\r\n}\r\nfunction posComment(s) {\r\n    //find position of comment in command line - any of the following can be used\r\n    let ipos = s.indexOf('\x3c!--');\r\n    if (ipos <= 0) {\r\n        ipos = s.indexOf('--');\r\n    }\r\n    if (ipos <= 0) {\r\n        ipos = s.indexOf('//');\r\n    }\r\n    if (ipos <= 0) {\r\n        ipos = s.indexOf('#');\r\n    }\r\n    return ipos;\r\n}\r\nfunction getScriptSettings(currentFolder) {\r\n    //get temp,exec,cd,swap & swapExp from config settings array `arr`\r\n    if (arr.length > 3) {\r\n        temp = arr[3];\r\n    }\r\n    exec = replaceStrVars(arr[0]);\r\n    if (arr.length > 1) {\r\n        cd = replaceStrVars(arr[1]);\r\n        if (cd !== '') {\r\n            cd += '\\n';\r\n        }\r\n    }\r\n    if (arr.length > 2) {\r\n        swap = arr[2].substr(0, 3); // {{ is the start, the end is }}\r\n        swapExp = arr[2].substr(3);\r\n    }\r\n}\r\nfunction replaceStrVars(s) {\r\n    return s.replace(/%f/g, tempd + temp).replace(/%p/g, tempd)\r\n        .replace(/%c/g, currentFolder).replace(/%n/g, temp).replace(/%e/g, currentFile);\r\n}\r\nfunction removeSelection() {\r\n    const { activeTextEditor } = vscode.window;\r\n    if (activeTextEditor) {\r\n        replaceSel = new vscode.Selection(startCode, 0, startCode, 0);\r\n        activeTextEditor.selection = replaceSel;\r\n    }\r\n}\r\nconst execShell = (cmd) => //execute shell command (to start scripts) \r\n new Promise((resolve, reject) => {\r\n    ch = cp.exec(cmd, (err, out) => {\r\n        if (err) {\r\n            return resolve(cmd + ' error!'); //reject(err);\r\n        }\r\n        return resolve(out);\r\n    });\r\n});\r\nfunction writeFile(file, text) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        yield vscode.workspace.fs.writeFile(vscode.Uri.file(file), Buffer.from(text));\r\n    });\r\n}\r\nfunction getCodeBlockAt(doc, pos) {\r\n    //return code in code block depending on type\r\n    const { activeTextEditor } = vscode.window;\r\n    let s = '';\r\n    startCode = 0;\r\n    if (activeTextEditor) {\r\n        let n = doc.lineAt(pos).lineNumber + 1;\r\n        if (oneLiner) {\r\n            let s1 = doc.lineAt(pos).text.slice(3);\r\n            startCode = n;\r\n            s1 = s1.slice(s1.indexOf(' ') + 1, s1.indexOf('```'));\r\n            return replaceStrVars(s1);\r\n        }\r\n        if (doc.lineAt(pos).text.endsWith('```')) {\r\n            startCode = n;\r\n            return '';\r\n        }\r\n        startCode = n;\r\n        while (n < doc.lineCount) {\r\n            let a = doc.lineAt(new vscode.Position(n, 0)).text;\r\n            n++;\r\n            if (a.startsWith('```')) {\r\n                break;\r\n            }\r\n            else {\r\n                s = s + a + '\\n';\r\n            }\r\n        }\r\n    }\r\n    return s;\r\n}\r\nfunction selectCodeblock() {\r\n    //select code block appropriately depending on type\r\n    const { activeTextEditor } = vscode.window;\r\n    if (activeTextEditor && startCode > 0) {\r\n        const doc = activeTextEditor.document;\r\n        let n = startCode;\r\n        if (oneLiner) {\r\n            n -= 1;\r\n        }\r\n        while (n < doc.lineCount) {\r\n            n++;\r\n            let a = doc.lineAt(new vscode.Position(n, 0)).text;\r\n            if (a.startsWith('```')) {\r\n                n++;\r\n                if (oneLiner && n === startCode + 1 && a === '```output') {\r\n                    //continue past start of output section\r\n                }\r\n                else if (!oneLiner && n < doc.lineCount && doc.lineAt(new vscode.Position(n, 0)).text === '```output') {\r\n                    //continue past start of output section\r\n                }\r\n                else {\r\n                    if (oneLiner && n === startCode + 1) {\r\n                        replaceSel = new vscode.Selection(startCode, 0, n - 1, 0);\r\n                    }\r\n                    else {\r\n                        replaceSel = new vscode.Selection(startCode, 0, n, 0);\r\n                    }\r\n                    activeTextEditor.selection = replaceSel;\r\n                    break;\r\n                }\r\n            }\r\n            else if (oneLiner && n <= startCode) {\r\n                replaceSel = new vscode.Selection(n, 0, n, 0);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return;\r\n}\r\nfunction deleteOutput(asText) {\r\n    //delete output code block (or leave as ordinary text without backtick lines\r\n    const { activeTextEditor } = vscode.window;\r\n    if (activeTextEditor) {\r\n        selectCodeblock();\r\n        if (asText) {\r\n            let pos1 = activeTextEditor.selection.start.line + 1;\r\n            let pos2 = activeTextEditor.selection.end.line - 1;\r\n            ;\r\n            let sel = new vscode.Selection(pos1, 0, pos2, 0);\r\n            activeTextEditor.edit((selText) => {\r\n                selText.replace(activeTextEditor.selection, activeTextEditor.document.getText(sel));\r\n            });\r\n        }\r\n        else {\r\n            activeTextEditor.edit((selText) => {\r\n                selText.replace(activeTextEditor.selection, '');\r\n            });\r\n        }\r\n    }\r\n}\r\nfunction deactivate() {\r\n}\r\nexports.deactivate = deactivate;\r\nfunction progress1(msg) {\r\n    //show a 'progress' pop up for 4 sec (bottom right) - not currently used\r\n    if (shown || msg === \"\") {\r\n        return;\r\n    }\r\n    let p = vscode.window.withProgress({\r\n        location: vscode.ProgressLocation.Notification,\r\n        title: \"hover-exec\", cancellable: false\r\n    }, (progress) => {\r\n        shown = true;\r\n        progress.report({ increment: -1, message: msg });\r\n        let p = new Promise(resolve => {\r\n            setTimeout(() => {\r\n                resolve();\r\n                shown = false;\r\n            }, 4000);\r\n        });\r\n        return p;\r\n    });\r\n    return p;\r\n}\r\n\n\n//# sourceURL=webpack://hover-exec/./src/extension.ts?")},129:e=>{e.exports=require("child_process")},549:e=>{e.exports=require("vscode")}},__webpack_module_cache__={};function __webpack_require__(e){var r=__webpack_module_cache__[e];if(void 0!==r)return r.exports;var n=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e].call(n.exports,n,n.exports,__webpack_require__),n.exports}var __webpack_exports__=__webpack_require__(112);module.exports=__webpack_exports__})();